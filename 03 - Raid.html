<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>03 - RAID</title>
  <link rel="icon" type="image/x-icon" href="Icon.ico">
  <style>
    :root {
      --bg: #8d8d8db9;
      --back-link-bg: rgba(255,255,255,0.45);
      --text: #2d2d2d;
      --container-bg: #ffffff;
      --header-bg: linear-gradient(90deg, #b46900f6, #d87e00);
      --header-text: #ffffff;
      --section-bg: #e2e2e2a0;
      --section-title: #000000;
      --section-title-bg: #cfcfcf54;
      --section-title-border: #F18E00;
      --h3: #cb6201cd;
      --trennlinie: #e0e7ef;
      --link: #d87e00;
      --link-hover: #ae6600;
      --back-link-bg: #9b948e40;
      --back-link: #e87000;
      --back-link-hover-bg: #ffffff;
      --back-link-hover: #e38101;
      --aside-bg: #e3e3e3;
      --aside-shadow: rgba(50, 58, 78, 0.556);
      --container-shadow: 0 2px 16px rgba(180,200,255,0.10);
      --sublist-color: #717171;
    }
    body.dark {
      --bg: #424242e7;
      --back-link-bg: rgba(60,60,60,0.45);
      --text: #f3f3f3;
      --container-bg: #353535fc;
      --header-bg: linear-gradient(90deg, #b46900, #d87e00);
      --header-text: #ffffff;
      --section-bg: #414040b9;
      --section-title: #ffffff;
      --section-title-bg: #d05a004c;
      --section-title-border: #d87e00;
      --h3: #d87e00;
      --trennlinie: #44495a;
      --link: #d87e00;
      --link-hover: #ae6600;
      --back-link-bg: #9b948e40;
      --back-link: #e87000;
      --back-link-hover-bg: #c8c6c651;
      --back-link-hover: #e38101;
      --aside-bg: #453f3c53;
      --aside-shadow: rgba(60,60,80,0.12);
      --container-shadow: 0 2px 16px rgba(60,60,80,0.18);
      --sublist-color: #cccccc;
    }
    body {
      background-color: var(--bg);
      color: var(--text);
      font-family: "Segoe UI", Arial, sans-serif;
      margin: 0;
      padding: 0;
      transition: background 0.3s, color 0.3s;
    }
    .container {
      max-width: 1000px;
      margin: 40px auto;
      background: var(--container-bg);
      border-radius: 16px;
      box-shadow: var(--container-shadow);
      padding: 36px;
      transition: background 0.3s;
    }
    header {
      background: var(--header-bg);
      color: var(--header-text);
      padding: 24px 0 16px 0;
      border-radius: 16px 16px 0 0;
      text-align: center;
      box-shadow: 0 2px 8px var(--aside-shadow);
      transition: background 0.3s, color 0.3s;
    }
    h1 {
      margin: 0;
      font-size: 2em;
      letter-spacing: 1px;
      color: #ffffff;
    }
    section {
      padding: 20px 24px;
      border-radius: 12px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.08);
      margin-bottom: 28px;
      transition: background 0.3s;
      background: var(--section-bg);
    }
    .section-title {
      font-size: 1.4em;
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 12px;
      color: var(--section-title);
      border-left: 4px solid var(--section-title-border);
      padding-left: 8px;
      background: var(--section-title-bg);
      border-radius: 4px;
      transition: background 0.3s, color 0.3s;
    }
    p {
      margin-bottom: 16px;
      line-height: 1.9;
    }
    ul {
      margin-bottom: 24px;
      padding-left: 20px;
    }
    li {
      margin-bottom: 14px;
      line-height: 1.9;
    }
    ul ul {
      margin-top: 6px;
      margin-bottom: 12px;
      list-style-type: circle;
      color: var(--sublist-color);
    }
    h3 {
      margin-top: 20px;
      color: var(--h3);
    }
    .trennlinie {
      border: none;
      border-top: 1px solid var(--trennlinie);
      margin: 32px 0;
      transition: border-color 0.3s;
    }
    a {
      color: var(--link);
      text-decoration: none;
      font-weight: 600;
      transition: color 0.2s;
    }
    a:hover {
      color: var(--link-hover);
    }
    .back-link {
      display: inline-block;
      margin-top: 16px;
      background: var(--back-link-bg);
      color: var(--back-link);
      padding: 10px 18px;
      border-radius: 8px;
      font-weight: 600;
      text-decoration: none;
      transition: background 0.2s, color 0.2s;
      border: 1px solid var(--trennlinie);
    }
    .back-link:hover {
      background: var(--back-link-hover-bg);
      color: var(--back-link-hover);
    }
    aside {
      background: var(--aside-bg);
      border-radius: 8px;
      padding: 18px 24px;
      margin-top: 24px;
      box-shadow: 0 1px 4px var(--aside-shadow);
      transition: background 0.3s;
    }
    .mode-toggle {
      position: fixed;
      top: 24px;
      right: 24px;
      z-index: 100;
      background: var(--back-link-bg);
      color: var(--back-link);
      border: 1px solid var(--trennlinie);
      border-radius: 8px;
      padding: 10px 18px;
      font-size: 1em;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .mode-toggle:hover {
      background: var(--back-link-hover-bg);
      color: var(--back-link-hover);
    }
    @media (max-width: 800px) {
      .container {
        max-width: 95%;
        padding: 16px;
      }
      h1 {
        font-size: 1.5em;
      }
      .mode-toggle {
        top: 8px;
        right: 8px;
        padding: 8px 12px;
      }
    }
    </style>
</head>
<body>
    <button class="mode-toggle" onclick="toggleMode()">üåô Dunkelmodus</button>
    <div class="container">
        <main>
        <header>
            <h1>03 - RAID</h1>
        </header>
        <section>
        <h2 class="section-title">1. Was ist ein RAID-System?</h2>
        <p>Ein RAID-System (Redundant Array of Independent Disks) fasst mehrere physische Laufwerke zu einem logischen Laufwerk zusammen, um drei Ziele zu erreichen: erh√∂hte Ausfallsicherheit, bessere Performance und/oder gr√∂√üere Gesamtkapazit√§t. Je nach gew√§hltem RAID-Level steht eines dieser Ziele st√§rker im Vordergrund: manche Level konzentrieren sich auf Geschwindigkeit (z. B. RAID 0), andere auf Redundanz (z. B. RAID 1, RAID 6) oder auf einem Kompromiss aus beidem (RAID 5, RAID 10). Wichtig zu merken ist immer: <b>RAID ersetzt kein Backup</b> ‚Äî RAID sch√ºtzt vor Hardwareausfall, nicht vor versehentlichem L√∂schen, Ransomware oder Datenkorruption.</p>
        <h3>Ziele von RAID (kurz erkl√§rt)</h3>
        <ul>
            <li><b>Erh√∂hte Ausfallsicherheit:</b> Durch Spiegelung oder Parit√§t k√∂nnen einzelne Laufwerke ausfallen, ohne dass Daten verloren gehen.</li>
            <li><b>H√∂here Geschwindigkeit:</b> Durch paralleles Lesen/Schreiben auf mehrere Platten steigt der Durchsatz.</li>
            <li><b>Gr√∂√üere Kapazit√§t:</b> Mehrere Platten werden zu einem gro√üen logischen Volume zusammengefasst; nutzbare Kapazit√§t h√§ngt vom Level ab.</li>
        </ul>
        </section>

        <hr class="trennlinie">
        
        <section>
        <div class="section-title">2. Hardware-RAID vs. Software-RAID (und "FakeRAID")</div>
        <p>RAID kann auf verschiedene Arten realisiert werden:</p>
        <ul>
            <li><b>Hardware-RAID (dedizierter RAID-Controller):</b> Ein eigener Controller (z. B. PCIe-Karte oder eingebauter Server-Controller) organisiert Striping, Parit√§t und Rebuilds. Vorteile sind Offload der CPU, oft integrierter Cache und Batterie/SuperCap-Absicherung des Caches (ohne funktionierendes Akku-/SuperCap-Modul f√§llt der Controller in den Write-Through-Modus). Das macht Hardware-RAID bei hohen Lasten und in professionellen Umgebungen performant.</li>
            <li><b>Software-RAID:</b> Das Betriebssystem (z. B. Linux <small>mdadm</small>, Windows Storage Spaces) verwaltet das RAID. Vorteil ist Kostenersparnis, Flexibilit√§t und meist gute Performance auf modernen CPUs; Nachteil: CPU-Last und eventuell weniger Hardware-spezifische Features (z. B. Battery-Backed Cache).</li>
            <li><b>Firmware/Host-RAID (oft "FakeRAID" genannt):</b> Eine Mischung aus BIOS/UEFI-Unterst√ºtzung und Treiber; lohnt sich meist nur in sehr speziellen F√§llen und kann weniger portabel/robust sein.</li>
        </ul>
        <p>Wenn du Systeme planst, entscheide nach Anforderungen an Performance, Management-Funktionen (Monitoring, Hot-spare, Rebuild-Priorit√§ten) und Budget.</p>
        </section>

        <hr class="trennlinie">
        
        <section>
        <div class="section-title">3. Wichtige RAID-Level (mit Erkl√§rungen und Beispielen)</div>
        <article>
            <h3>RAID 0 ‚Äî Striping (Leistung, keine Redundanz)</h3>
            <p>Bei RAID 0 werden Daten blockweise √ºber die Platten verteilt ("striped"). Das erh√∂ht Lese- und Schreibdurchsatz, weil mehrere Platten parallel arbeiten. Die Gesamtkapazit√§t ist die Summe der Plattenkapazit√§ten. <b>Es gibt keine Redundanz:</b> f√§llt eine Platte aus, sind die Daten auf dem Array verloren.</p>
            <p>Beispiel mit 2x4 TB &rarr; nutzbare Kapazit√§t = 8 TB, hohe Performance, aber kein Schutz. Typische Einsatzzwecke: tempor√§re Daten (z. B. Videoschnitt-Cache), Testsysteme.</p>
        </article>
        <br>
        <article>
            <h3>RAID 1 ‚Äî Mirroring (Spiegelung)</h3>
            <p>RAID 1 schreibt identische Daten auf zwei (oder mehr) Platten. Das ergibt hohe Ausfallsicherheit: eine Platte kann ausfallen, ohne dass Daten verloren gehen. Die nutzbare Kapazit√§t entspricht der kleinsten Platte; bei zwei gleichen Platten ist sie also 50% der Rohkapazit√§t. Lesezugriffe k√∂nnen beschleunigt werden (Parallellesen), Schreibzugriffe haben in der Praxis fast die Performance einer einzelnen Platte, da alle Spiegel gleichzeitig beschrieben werden.</p>
            <p>Beispiel: 2x4 TB &rarr; nutzbar 4 TB, eine Platte darf ausfallen.</p>
        </article>
        <br>
        <article>
            <h3>RAID 5 ‚Äî Striping mit einfacher Parit√§t</h3>
            <p>RAID 5 verteilt Datenbl√∂cke und eine Parit√§tsinformation so √ºber mehrere Platten, dass der Ausfall einer Platte durch Rekonstruktion aus den verbleibenden Daten und der Parit√§t wiederhergestellt werden kann. Minimum sind 3 Platten. Nutzbare Kapazit√§t = (n - 1) x Kapazit√§t der kleinsten Platte. Lesen ist schnell (parallel), Schreiben ben√∂tigt zus√§tzliche Arbeit (Parit√§tsberechnung), sodass kleine zuf√§llige Schreibvorg√§nge langsamer sind als bei RAID 1.</p>
            <p>Beispiel: 3x4 TB &rarr; nutzbar 8 TB (3-1 = 2 x 4 TB).</p>
            <p>Vorsicht: bei sehr gro√üen Platten und vielen Spindeln steigt das Risiko, dass w√§hrend eines Rebuilds ein weiterer Fehler (z. B. URE) auftritt.</p>
        </article>
        <br>
        <article>
            <h3>RAID 6 ‚Äî Striping mit doppelter Parit√§t</h3>
            <p>RAID 6 erweitert RAID 5 um eine zweite, unabh√§ngige Parit√§tsinformation. Dadurch √ºberlebt das Array gleichzeitig zwei Plattenausf√§lle. Minimum sind 4 Platten. Nutzbare Kapazit√§t = (n - 2) x Kapazit√§t der kleinsten Platte. Leseleistung ist gut; Schreibperformance ist durch doppelte Parit√§tsberechnung st√§rker beeintr√§chtigt als bei RAID 5. RAID 6 ist f√ºr gro√üe Arrays mit gro√üen HDDs h√§ufig die sicherere Wahl.</p>
            <p>Beispiel: 4x4 TB &rarr; nutzbar 8 TB (4-2 = 2 x 4 TB).</p>
        </article>
        <br>
        <article>
            <h3>RAID 10 (1+0) ‚Äî Mirrored Stripes (Spiegel + Striping)</h3>
            <p>RAID 10 ist eine Kombination aus Spiegelung und Striping: Zuerst werden Spiegelpaare (RAID-1) gebildet, diese Paare werden dann √ºber Striping verbunden (RAID-0 √ºber die Spiegel). Minimum sind 4 Platten (zwei Spiegelpaare). Die nutzbare Kapazit√§t ist 50 % der Rohkapazit√§t (wie bei RAID 1), bietet aber hohe Lese- und sehr gute Schreibperformance sowie sehr gute Ausfallsicherheit, da mehrere Platten ausfallen k√∂nnen, solange nicht beide Platten desselben Spiegelpaares verloren gehen. Wenn zuf√§llig beide Platten eines Paares sterben, ist das Array tot - das ist ein zentrales Risiko. RAID 10 ist in vielen produktiven Umgebungen die bevorzugte Wahl, wenn Performance und Redundanz wichtig sind.</p>
            <p>Beispiel: 4x4 TB &rarr; nutzbar 8 TB.</p>
        </article>
        <br>
        <h3>Kurzvergleich (vereinfachte √úbersicht):</h3>
        <ul>
            <li><b>RAID 0:</b> min. 2 Platten; Kapazit√§t = n x size; keine Redundanz; sehr hoch in Performance.</li>
            <li><b>RAID 1:</b> min. 2; Kapazit√§t = 1 x size (bei 2 Platten); 1 Platte f√§llt aus; sehr sicher.</li>
            <li><b>RAID 5:</b> min. 3; Kapazit√§t = (n-1)xsize; 1 Platte f√§llt aus; guter Kompromiss.</li>
            <li><b>RAID 6:</b> min. 4; Kapazit√§t = (n-2)xsize; 2 Platten fallen aus; sehr sicher bei gro√üen Arrays.</li>
            <li><b>RAID 10:</b> min. 4; Kapazit√§t = (n √∑ 2) x size; sehr gute Performance + Redundanz.</li>
        </ul>
        <h3>Typische Vor- und Nachteile (kurz erl√§utert)</h3>
        <ul>
            <li><b>RAID 0:</b> + maximale Kapazit√§t/Performance; - kein Schutz.</li>
            <li><b>RAID 1:</b> + sehr stabil/schnelle Wiederherstellung; - nur 50 % Kapazit√§t.</li>
            <li><b>RAID 5:</b> + effizienter Platzgebrauch; - anf√§lliger bei gro√üen Platten w√§hrend Rebuild.</li>
            <li><b>RAID 6:</b> + robust bei doppeltem Ausfall; - h√∂herer Schreib-Overhead.</li>
            <li><b>RAID 10:</b> + sehr gute Performance & Redundanz; - 50 % Kapazit√§tsverlust wie bei RAID 1, teurer.</li>
        </ul>
        </section>

        <hr class="trennlinie">

        <section>
        <div class="section-title">4. Rebuilds ‚Äî wie funktioniert Wiederherstellung praktisch?</div>
        <p>Ein Rebuild ist der Prozess, mit dem ein RAID-Controller nach dem Austausch einer defekten Platte die fehlenden Daten auf die Ersatzplatte rekonstruiert.</p>
        <ul>
            <li><b>Allgemeines Prinzip:</b> Bei Parit√§ts-RAIDs (RAID 5/6) liest der Controller die entsprechenden Datenbl√∂cke und schreibt diese auf die Ersatzplatte. Bei RAID 1 wird die neue Platte einfach kopiert (Block f√ºr Block) von der intakten Platte.</li>
            <li><b>RAID 1:</b> Rebuild ist vergleichsweise schnell, weil nur eine Platte gelesen und die andere beschrieben wird; es gibt keine Parit√§tsberechnung. Dennoch gilt: W√§hrend des Rebuilds besteht keine Redundanz ‚Äî f√§llt die verbliebene Platte aus, sind die Daten verloren. Lesefehler auf der verbleibenden Platte k√∂nnen den Rebuild abbrechen.</li>
            <li><b>RAID 5:</b> Rebuild erfordert, dass bei jedem Block die anderen n-1 Platten gelesen werden; das belastet das Array stark und erh√∂ht die Gefahr eines zweiten Fehlers (z. B. URE), besonders bei sehr gro√üen Platten. Daher k√∂nnen Rebuilds viele Stunden bis Tage dauern (je nach Plattengr√∂√üe und Systemlast).</li>
            <li><b>Herstellerspezifische Hinweise (HPE & QNAP):</b></li>
            <ul>
                <li>Bei <b>HPE Smart Array Controllern</b> h√§ngt die Rebuild-Performance stark vom Cache-Modul ab. Mit aktiviertem Write-Back-Cache und funktionierender Batterie-/SuperCap-Absicherung laufen Rebuilds deutlich schneller. F√§llt die Absicherung aus, schaltet der Controller in den Write-Through-Modus, wodurch Rebuilds sehr viel l√§nger dauern k√∂nnen.</li>
                <li>Bei <b>QNAP NAS-Systemen</b> werden Rebuilds im QTS- oder QuTS-Betriebssystem meist standardm√§√üig im Hintergrund mit niedriger Priorit√§t ausgef√ºhrt, um die laufenden Dienste (Dateifreigaben, VMs, Backups) nicht zu stark zu beeintr√§chtigen. Dadurch verl√§ngert sich die Rebuild-Dauer erheblich, was aber die Produktivnutzung stabiler h√§lt. Administratoren k√∂nnen die Priorit√§t manuell anpassen, falls ein schnellerer Rebuild wichtiger ist als aktuelle Performance.</li>
            </ul>
            <li><b>Hot Spare:</b> Viele Systeme besitzen einen Hot-Spare (vorgehaltene Ersatzplatte). F√§llt eine Platte aus, startet der Rebuild automatisch auf dem Hot-Spare. Das reduziert die Zeit ohne Redundanz. Manche Controller unterst√ºtzen auch ‚ÄûGlobal Hot-Spare‚Äú (f√ºr alle Arrays) oder ‚ÄûDedicated Hot-Spare‚Äú (nur f√ºr ein bestimmtes Array).</li>
            <li><b>URE-Risiko (Unrecoverable Read Error):</b> Gro√üe HDDs haben eine nicht-null Wahrscheinlichkeit f√ºr UREs beim Lesen gro√üer Datenmengen; w√§hrend eines RAID-5-Rebuilds kann ein URE zum kompletten Arrayverlust f√ºhren ‚Äî deswegen sind RAID-6 oder RAID-10 bei gro√üen Kapazit√§ten oft sicherer. UREs sind bei RAID 6 weniger kritisch, weil ein zus√§tzlicher Fehler noch abgefangen werden kann.</li>
        </ul>
        <p><b>Praktische Gr√∂√üenordnung:</b> Rebuildzeiten steigen mit Plattengr√∂√üe; heute k√∂nnen 8-16 TB HDDs beim Rebuild viele Stunden bis √ºber ein bis zwei Tage in Anspruch nehmen, je nach System-I/O und Priorisierung.</p>
        </section>
        
        <hr class="trennlinie">
        
        <section>
        <div class="section-title">5. Cache-Module & Absicherung (BBWC / SuperCap / FBWC)</div>
        <p>Viele Hardware-Controller haben einen Cache (DRAM), der I/O-Operationen puffert. Der Cache kann im Write-Back-Modus die Schreiblatenz stark reduzieren, weil Writes als abgeschlossen gelten, sobald sie im Controller-Cache liegen. Damit diese Daten bei Stromausfall nicht verloren gehen, gibt es Absicherungen:</p>
        <ul>
            <li><b>BBWC (Battery-Backed Write Cache):</b> Ein Akku (Battery) sichert den Cache, bis Daten persistent geschrieben werden.</li>
            <li><b>SuperCap / Flash-Backed (FBWC):</b> Moderne Systeme nutzen statt Akku einen Superkondensator (SuperCap), der kurzzeitig genug Energie liefert, damit der Cacheinhalt in nicht-fl√ºchtigen Speicher (Flash) geschrieben wird. Daher die Bezeichnung Flash-Backed Write Cache (FBWC). Ohne funktionierende Absicherung wird der Controller oft in Write-Through-Modus gezwungen (Writes gehen sofort auf die Platten), was die Schreibperformance merklich senkt.</li>
        </ul>
        <p>Beim Rebuild hilft ein sicherer Cache, weil er Schreibvorg√§nge beschleunigt und so die Zeit reduziert, in der das Array ohne vollst√§ndige Redundanz l√§uft.</p>
        </section>
        
        <hr class="trennlinie">
        
        <section>
        <h3 class="section-title">Wichtige Praxis-Tipps & Checkliste (f√ºr Planung und Betrieb)</h3>
        <ul>
            <li><b>Backups:</b> RAID &ne; Backup. Plane regelm√§√üige Backups und teste Recovery-Szenarien.</li>
            <li><b>Hot-Spare:</b> Wenn m√∂glich, ein Hot-Spare vorsehen, damit Rebuilds sofort starten.</li>
            <li><b>SMART-Monitoring:</b> SMART-Werte der Platten regelm√§√üig pr√ºfen (Reallocated Sectors, Pending Sectors).</li>
            <li><b>Firmware:</b> Laufwerks- und Controller-Firmware aktuell halten (Kompatibilit√§tslisten beachten). Nicht jede neue Firmware sofort einspielen, da Controller-/Disk-Firmware manchmal Bugs mitbringen. In Rechenzentren wird meist getestet, bevor upgedatet wird.</li>
            <li><b>Rebuild-Priorit√§t:</b> Bei hoher produktiver Belastung kann man Rebuild-Priorit√§t anpassen (schneller rebuild vs. weniger Performance-Impact).</li>
            <li><b>Scrubbing:</b> Periodische Daten-Integrit√§tspr√ºfungen (scrub) durchf√ºhren, um fehlerhafte Bl√∂cke fr√ºh zu finden.</li>
            <li><b>Gr√∂√üenwahl:</b> Bei sehr gro√üen HDDs lieber RAID 6 oder RAID 10 anstelle von RAID 5 w√§hlen.</li>
            <li><b>Dateisystemwahl:</b> Erw√§ge Dateisysteme mit Checksumming/Copy-On-Write (z. B. ZFS, Btrfs) ‚Äî diese bieten zus√§tzlichen Schutz vor stillen Fehlern (silent corruption). ZFS hat RAIDZ(1/2)-Konzepte, die RAID5/6 √§hneln, aber mit Checksummen und anderen Designunterschieden.</li>
        </ul>
        </section>

        <hr class="trennlinie">

        <section>
        <h3 class="section-title">Kurze Hinweise zu modernen Alternativen / Begriffen</h3>
        <ul>
            <li><b>RAIDZ (ZFS):</b> RAIDZ1 &asymp; RAID5 (einfach Parit√§t), RAIDZ2 &asymp; RAID6 (doppelte Parit√§t). ZFS bietet aber Checksumming, Copy-On-Write und "resilvering", was klassische RAID-Implementierungen in manchen Bereichen √ºberlegen macht.</li>
            <li><b>Scrubbing/Resilvering:</b> Periodisches √úberpr√ºfen und Wiederherstellen (bei ZFS hei√üt das "resilvering") reduziert das Risiko latenter Fehler.</li>
        </ul>
        </section>

        <hr class="trennlinie">

        <section>
        <div class="section-title">Fazit ‚Äî Wie w√§hlst du das richtige RAID?</div>
        <p>Die Wahl des RAID-Levels h√§ngt von Anforderungen ab: willst du maximale Performance (RAID 0), einfache und kosteng√ºnstige Redundanz (RAID 1), effiziente Kapazit√§tsnutzung mit Kompromiss (RAID 5), h√∂here Sicherheit bei gro√üen Arrays (RAID 6) oder eine robuste Kombination aus hohen Schreib-/Leseleistungen und Ausfallsicherheit (RAID 10)? Ber√ºcksichtige dabei immer Rebuild-Risiko, Plattengr√∂√üe, Wartungsprozesse (Hot-Spares, Scrubbing) sowie Backups und Monitoring-Konzept.</p>
        </section>
        
        <hr class="trennlinie">
        
        <a href="02 - Switching VLAN PoE.html" target="blank" class="back-link">&larr; Zur√ºck zu 02 - Switching / VLAN / PoE</a> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a href="04 - Verschl√ºsselung.html" target="blank" class="back-link">04 - Verschl√ºsselung &#8594;</a> 
        <br>
        <a href="Ausbildungsthemen.html" class="back-link">&lArr; Zur√ºck zum Inhaltsverzeichnis</a> 
        </main>
    </div>
    <script>
    function toggleMode() {
        document.body.classList.toggle('dark');
        const btn = document.querySelector('.mode-toggle');
        if(document.body.classList.contains('dark')) {
            btn.textContent = '‚òÄÔ∏è Hellmodus';
        } else {
            btn.textContent = 'üåô Dunkelmodus';
        }
    }
  </script>
</body>
</html>